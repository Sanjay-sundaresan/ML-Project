# -*- coding: utf-8 -*-
"""ML_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hHG4ZSJ93jPn2MOufvwp1ODvngPOh9Vz

# **Relationship between imbalance and overlapping of datasets - Imbalance and overlapping are considered together and treated as a single issue.**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import KFold 
from sklearn.metrics import classification_report
from sklearn import metrics
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn import svm 
from sklearn.model_selection import cross_val_score
from numpy import mean
from sklearn.datasets import make_classification

from google.colab import drive
drive.mount("/content/gdrive",force_remount=True)

"""Reading Synthetically generated Datasets"""

unbalanced_3F_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/unbalanced-3-F-overlaple.csv")

unbalanced_allF_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/unbalanced-all-F-overlap.csv")

unbalanced_noF_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/unbalanced-no-F-overlap.csv")

unbalanced_1F_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/unbalanced-one-F-overlap.csv")

Balanced_2F_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/Balanced-2-F-overlap.csv")

Balanced_3F_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/Balanced-3-F-overlap.csv")

Balanced_AllF_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/Balanced-All-F-overlap.csv")

Balanced_noF_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/Balanced-no-F-overlap.csv")

Balanced_oneF_overlap = pd.read_csv("/content/gdrive/My Drive/ML_DATA/Balanced-one-F-overlap.csv")

"""1. Consistency analysis of balanced dataset with all 4 features overlapping"""

Balanced_AllF_overlap.describe()

Balanced_AllF_overlap.skew()

"""2. Consistency analysis of **unbalanced** dataset with all 4 features overlapping"""

unbalanced_allF_overlap.describe()

unbalanced_allF_overlap.skew()

"""The skewness of the features in both cases indicates that the class boundaries are not very distinct, thus making classification more challenging.

3. Principal component analysis of balanced dataset with all features overlapping.
"""

features = ['X1','X2','X3','X4']
x = Balanced_AllF_overlap.loc[:, features].values
x = StandardScaler().fit_transform(x)
pd.DataFrame(data = x, columns = features).head()

pca = PCA(n_components= 4)
principalComponents = pca.fit_transform(x)
pca_df = pd.DataFrame(data = principalComponents, columns = ['Component 1', 'Component 2', 'Component 3', 'Component 4'])
pca_df.head()

B = pd.DataFrame(["Component 1", "Component 2","Component 3","Component 4"], columns = ["Component"])
Bdf = pd.DataFrame(pca.explained_variance_ratio_ * 100, columns= ["Perc_of_Variance"])
Bdf = pd.concat([B, Bdf], axis = 1)
Bd = Bdf.Perc_of_Variance.values
Bd1= [0,0,0,0]
for i in range(0,4):
  if i == 0 :
    Bd1[i] = Bd[i]
  else:
    Bd1[i] = Bd[i] + Bd1[i-1] 
Bdf['Cumulative_Perc'] = Bd1
Bdf.head()

"""4. Principal component analysis of **unbalanced** dataset with all features overlapping. """

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = StandardScaler().fit_transform(x)
pd.DataFrame(data = x, columns = features).head()

pca = PCA(n_components= 4)
principalComponents = pca.fit_transform(x)
pca_df = pd.DataFrame(data = principalComponents, columns = ['Component 1', 'Component 2', 'Component 3', 'Component 4'])
pca_df.head()

B = pd.DataFrame(["Component 1", "Component 2","Component 3","Component 4"], columns = ["Component"])
Bdf = pd.DataFrame(pca.explained_variance_ratio_ * 100, columns= ["Perc_of_Variance"])
Bdf = pd.concat([B, Bdf], axis = 1)
Bd = Bdf.Perc_of_Variance.values
Bd1= [0,0,0,0]
for i in range(0,4):
  if i == 0 :
    Bd1[i] = Bd[i]
  else:
    Bd1[i] = Bd[i] + Bd1[i-1] 
Bdf['Cumulative_Perc'] = Bd1
Bdf.head()

"""For balanced data, the first component explains ~60.66% of the
total variance, the second component explains ~25.33%, and the fourth one represents ~3.05% of the variance. The PCA for unbalanced dataset, however, indicated that the first PCA component explains only ~36.1% of the variance, the second one ~28.9%, and the fourth one accounted for 10.1% of
the variance. This provides an idea about the difference in the distribution of the balanced and unbalanced sets with full overlapping.

**Using 10-fold Cross-Validation to evaluate the models and ultimately compare the performance of different datasets.**
"""

Kfold = KFold(10,shuffle = True)
overall_acc = []
overall_prec = []
overall_rec = []
sc = []

"""5. **Running SVM classifier using 10-fold cross validation for balanced and unbalanced datasets with varying degrees of overlapping**

5.1: **Balanced dataset with 1 feature overlap**
"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_oneF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features) 
y = Balanced_oneF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Balanced-1-F-overlap")

"""5.2: **Unbalanced dataset with 1 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_1F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_1F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Unbalanced-1-F-overlap")

"""5.3: **Balanced dataset with 2 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_2F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_2F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Balanced-2-F-overlap")

"""5.4: **Balanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Balanced-3-F-overlap")

"""5.5: **Unbalanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Unbalanced-3-F-overlap")

"""5.6: **Balanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_AllF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_AllF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Balanced-all-F-overlap")

"""5.7: **Unbalanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_allF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Unbalanced-all-F-overlap")

"""5.8: **Balanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Balanced-no-F-overlap")

"""5.9: **Unbalanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = unbalanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

clf = svm.SVC()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc.append(mean(accuracies) * 100)
overall_prec.append(mean(precisions) * 100)
overall_rec.append(mean(recalls) * 100)
sc.append("Unbalanced-no-F-overlap")

"""Tabulating the results,"""

SVM_Res = pd.DataFrame(list(zip(sc, overall_acc, overall_prec, overall_rec)), columns = ['SVM - Dataset nature','Accuracy%','Precision%','Recall%'])
SVM_Res

"""6. **Running Decision tree classifier using 10-fold cross validation for balanced and unbalanced datasets with varying degrees of overlapping**"""

Kfold = KFold(10, shuffle= True)
overall_acc_dtc = []
overall_prec_dtc = []
overall_rec_dtc = []
sc_dtc = []

"""6.1: **Balanced dataset with 1 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_oneF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_oneF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Balanced-1-F-overlap")

"""6.2: **Unbalanced dataset with 1 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_1F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_1F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Unbalanced-1-F-overlap")

"""6.3: **Balanced dataset with 2 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_2F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_2F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Balanced-2-F-overlap")

"""6.4: **Balanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Balanced-3-F-overlap")

"""6.5: **Unbalanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Unbalanced-3-F-overlap")

"""6.6: **Balanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_AllF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_AllF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Balanced-all-F-overlap")

"""6.7: **Unbalanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_allF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Unbalanced-all-F-overlap")

"""6.8: **Balanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Balanced-no-F-overlap")

"""6.9: **Unbalanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = unbalanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_dtc.append(mean(accuracies) * 100)
overall_prec_dtc.append(mean(precisions) * 100)
overall_rec_dtc.append(mean(recalls) * 100)
sc_dtc.append("Unbalanced-no-F-overlap")

"""Tabulating the results,"""

DTC_results= pd.DataFrame(list(zip(sc_dtc, overall_acc_dtc, overall_prec_dtc, overall_rec_dtc)), columns = ['DTC - Dataset nature','Accuracy%','Precision%','Recall%'])
DTC_results

"""7. **Running KNN (k = 3) classifier using 10-fold cross validation for balanced and unbalanced datasets with varying degrees of overlapping**"""

Kfold = KFold(10, shuffle=True)
overall_acc_knn = []
overall_prec_knn = []
overall_rec_knn = []
sc_knn = []

"""7.1: **Balanced dataset with 1 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_oneF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_oneF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Balanced-1-F-overlap")

"""7.2: **Unbalanced dataset with 1 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_1F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_1F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Unbalanced-1-F-overlap")

"""7.3: **Balanced dataset with 2 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_2F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_2F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Balanced-2-F-overlap")

"""7.4: **Balanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Balanced-3-F-overlap")

"""7.5: **Unbalanced dataset with 3 feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_3F_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_3F_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Unbalanced-3-F-overlap")

"""7.6: **Balanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = Balanced_AllF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_AllF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Balanced-all-F-overlap")

"""7.7: **Unbalanced dataset with all feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_allF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Unbalanced-all-F-overlap")

"""7.8: **Balanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = Balanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = Balanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Balanced-no-F-overlap")

"""7.9: **Unbalanced dataset with no feature overlap**"""

accuracies = []
precisions = []
recalls = []

features = [' X1','X2','X3','X4']
x = unbalanced_noF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_noF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
print("Accuracy:",mean(accuracies))
print("Precision:",mean(precisions))
print("Recall:",mean(recalls))
overall_acc_knn.append(mean(accuracies) * 100)
overall_prec_knn.append(mean(precisions) * 100)
overall_rec_knn.append(mean(recalls) * 100)
sc_knn.append("Unbalanced-no-F-overlap")

"""Tabulating the results,"""

KNN_Res = pd.DataFrame(list(zip(sc_knn, overall_acc_knn, overall_prec_knn, overall_rec_knn)), columns = ['KNN - Dataset nature','Accuracy%','Precision%','Recall%'])
KNN_Res

"""8. **Oversampling an unbalanced dataset with all features overlapping using ADASYN
algorithm, before running all three classifiers**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from imblearn.over_sampling import ADASYN
from collections import Counter
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

overall_acc_ovs = []
overall_prec_ovs = []
overall_rec_ovs = []
sc_ovs = []

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_allF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

ada = ADASYN(sampling_strategy='minority', random_state= 420 , n_neighbors = 5)
x_res, y_res = ada.fit_resample(x,y)

#SVM 
accuracies = []
precisions = []
recalls = []
clf = svm.SVC()
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_ovs.append(mean(accuracies) * 100)
overall_prec_ovs.append(mean(precisions) * 100)
overall_rec_ovs.append(mean(recalls) * 100)
sc_ovs.append("SVM Classifier")

#Decision Tree Classifier
accuracies = []
precisions = []
recalls = []
clf = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_ovs.append(mean(accuracies) * 100)
overall_prec_ovs.append(mean(precisions) * 100)
overall_rec_ovs.append(mean(recalls) * 100)
sc_ovs.append("Decision Tree Classifier")

#KNN
accuracies = []
precisions = []
recalls = []
clf = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_ovs.append(mean(accuracies) * 100)
overall_prec_ovs.append(mean(precisions) * 100)
overall_rec_ovs.append(mean(recalls) * 100)
sc_ovs.append("KNN Classifier")

Oversampling_Res = pd.DataFrame(list(zip(sc_ovs, overall_acc_ovs, overall_prec_ovs, overall_rec_ovs)), columns = ['Resampling: over-sampling','Accuracy%','Precision%','Recall%'])
Oversampling_Res

"""9. **Undersampling the majority class in an unbalanced dataset with all features overlapping
using Random Under Sampler algorithm, before running all three classifiers.**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from imblearn.under_sampling import RandomUnderSampler
from collections import Counter
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

overall_acc_uns = []
overall_prec_uns = []
overall_rec_uns = []
sc_uns = []

features = ['X1','X2','X3','X4']
x = unbalanced_allF_overlap.loc[:, features].values
x = pd.DataFrame(data = x, columns = features)
y = unbalanced_allF_overlap.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

Rus = RandomUnderSampler(sampling_strategy='majority')
x_res, y_res = Rus.fit_resample(x,y)

#SVM 
accuracies = []
precisions = []
recalls = []
clf = svm.SVC()
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_uns.append(mean(accuracies) * 100)
overall_prec_uns.append(mean(precisions) * 100)
overall_rec_uns.append(mean(recalls) * 100)
sc_uns.append("SVM Classifier")

#Decision Tree Classifier
accuracies = []
precisions = []
recalls = []
dtc = DecisionTreeClassifier()
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  dtc.fit(x_train, y_train)
  pred = dtc.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_uns.append(mean(accuracies) * 100)
overall_prec_uns.append(mean(precisions) * 100)
overall_rec_uns.append(mean(recalls) * 100)
sc_uns.append("Decision Tree Classifier")

#KNN
accuracies = []
precisions = []
recalls = []
knn = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kfold.split(x_res):
  x_train, x_test, y_train, y_test = x_res[train_index], x_res[test_index], y_res[train_index], y_res[test_index]
  knn.fit(x_train, y_train)
  pred = knn.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
overall_acc_uns.append(mean(accuracies) * 100)
overall_prec_uns.append(mean(precisions) * 100)
overall_rec_uns.append(mean(recalls) * 100)
sc_uns.append("KNN Classifier")

Undersampling_Res = pd.DataFrame(list(zip(sc_uns, overall_acc_uns, overall_prec_uns, overall_rec_uns)), columns = ['Resampling: Under-sampling','Accuracy%','Precision%','Recall%'])
Undersampling_Res

"""# **Additional work: Combining oversampling and undersampling**

Now that the importance of solving the imbalance and overlapping problem has been highlighted, attempts at targeted alleviation can be made.
"""

X, y = make_classification(n_classes= 2, weights = [0.01, 0.99], n_features=21, n_samples= 5000)

o_df = pd.DataFrame(X, y)

# o_df.to_csv("/content/gdrive/My Drive/ML_DATA/new.csv")

df = pd.read_csv("/content/gdrive/My Drive/ML_DATA/new.csv")

df.tail()

"""**Now that a larger dataset with 21 predictors, 1 target and 5000 records has been generated, the classifier performance can be checked**"""

methods = []
DTC_Acc = []
KNN_Acc = []
SVM_Acc = []

DTC_Prec = []
KNN_Prec = []
SVM_Prec = [] 

DTC_Rec = []
KNN_Rec = []
SVM_Rec = []

Kf = KFold(10)

features = ['X1','X2','X3','X4','X5','X6','X7','X8','X9','X10','X11','X12','X13','X14','X15','X16','X17','X18','X19','X20','X21']
x = df.loc[:, features].values
x = pd.DataFrame(data = x, columns = features) 
y = df.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)

#SVM 
accuracies = []
precisions = []
recalls = []
clf = svm.SVC()
for train_index, test_index in Kf.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
SVM_Acc.append(mean(accuracies) * 100)
SVM_Prec.append(mean(precisions) * 100)
SVM_Rec.append(mean(recalls) * 100)
methods.append("Without resampling")

#DTC
accuracies = []
precisions = []
recalls = []
clf = DecisionTreeClassifier()
for train_index, test_index in Kf.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
DTC_Acc.append(mean(accuracies) * 100)
DTC_Prec.append(mean(precisions) * 100)
DTC_Rec.append(mean(recalls) * 100)

#KNN
accuracies = []
precisions = []
recalls = []
clf = KNeighborsClassifier(n_neighbors = 3)
for train_index, test_index in Kf.split(x):
  x_train, x_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]
  clf.fit(x_train, y_train)
  pred = clf.predict(x_test)
  accuracies.append(metrics.accuracy_score(y_test, pred))
  precisions.append(metrics.precision_score(y_test, pred))
  recalls.append(metrics.recall_score(y_test, pred))
KNN_Acc.append(mean(accuracies) * 100)
KNN_Prec.append(mean(precisions) * 100)
KNN_Rec.append(mean(recalls) * 100)

"""**1. Pipeline consisting of manual combination of SMOTE, random undersampling and finally the classifier**"""

from numpy import mean
from sklearn.datasets import make_classification
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.tree import DecisionTreeClassifier
from imblearn.pipeline import Pipeline
from imblearn.over_sampling import SMOTE
from imblearn.over_sampling import RandomOverSampler
from imblearn.under_sampling import RandomUnderSampler

x = df.loc[:, features].values
x = pd.DataFrame(data = x, columns = features) 
y = df.Y
scaler = MinMaxScaler(feature_range=(0, 1))
x = scaler.fit_transform(x)
model = DecisionTreeClassifier()
over = SMOTE(sampling_strategy=0.5)
under = RandomUnderSampler(sampling_strategy=0.5)

pipeline = Pipeline(steps=[('o', over), ('u', under), ('m', model)])

cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)

scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
DTC_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
DTC_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
DTC_Rec.append(mean(scores) * 100)

methods.append("Manual SMOTE + Random Undersampling")

#KNN
model = KNeighborsClassifier(n_neighbors = 3)
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
KNN_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
KNN_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
KNN_Rec.append(mean(scores) * 100)

#SVM 
model = svm.SVC()
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
SVM_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
SVM_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
SVM_Rec.append(mean(scores) * 100)

"""**2. Pipeline consisting of SMOTETomek resampling and classifier**"""

from imblearn.combine import SMOTETomek
from imblearn.under_sampling import TomekLinks

resample = SMOTETomek(tomek=TomekLinks(sampling_strategy='majority'))
pipeline = Pipeline(steps=[('r', resample), ('m', model)])

model = DecisionTreeClassifier()
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)

scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
DTC_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
DTC_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
DTC_Rec.append(mean(scores) * 100)

methods.append("SMOTETomek resampling")

#KNN
model = KNeighborsClassifier(n_neighbors = 3)
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)

scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
KNN_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
KNN_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
KNN_Rec.append(mean(scores) * 100)

#SVM 
model = svm.SVC()
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
SVM_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
SVM_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
SVM_Rec.append(mean(scores) * 100)

"""**3. Pipeline consisting of SMOTE + Edited Nearest Neighbors undersampling (SMOTEENN) and the classifier.** """

from imblearn.combine import SMOTEENN

resample = SMOTEENN()
pipeline = Pipeline(steps=[('r', resample), ('m', model)])

model = DecisionTreeClassifier()
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)

scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
DTC_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
DTC_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
DTC_Rec.append(mean(scores) * 100)

methods.append("SMOTEENN resampling")

#KNN
model = KNeighborsClassifier(n_neighbors = 3)
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)

scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
KNN_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
KNN_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
KNN_Rec.append(mean(scores) * 100)

#SVM 
model = svm.SVC()
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, x,y, scoring='accuracy', cv=cv, n_jobs=-1)
SVM_Acc.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='precision', cv=cv, n_jobs=-1)
SVM_Prec.append(mean(scores) * 100)

scores = cross_val_score(pipeline, x,y, scoring='recall', cv=cv, n_jobs=-1)
SVM_Rec.append(mean(scores) * 100)

"""**Tabulating the results**"""

Res_Acc = pd.DataFrame(list(zip(methods, DTC_Acc, KNN_Acc, SVM_Acc)), columns = ['Method','DTC Accuracy %','KNN Accuracy %','SVM Accuracy %'])

Res_Prec = pd.DataFrame(list(zip(methods, DTC_Prec, KNN_Prec, SVM_Prec)), columns = ['Method','DTC Precision %','KNN Precision %','SVM Precision %'])

Res_Rec = pd.DataFrame(list(zip(methods, DTC_Rec, KNN_Rec, SVM_Rec)), columns = ['Method','DTC Recall %','KNN Recall %','SVM Recall %'])

Res_Acc

Res_Prec

Res_Rec

"""**Plotting the results**"""

Enc_Methods = ["0","1","2","3"]
plt.plot(Enc_Methods, DTC_Acc)
plt.plot(Enc_Methods, KNN_Acc)
plt.plot(Enc_Methods, SVM_Acc)
plt.ylabel("Accuracy")
plt.xlabel("Method Number")
plt.legend(["DTC","KNN","SVM"])
plt.title("Accuracy Comparison of Resampling methods")

Enc_Methods = ["0","1","2","3"]
plt.plot(Enc_Methods, DTC_Prec)
plt.plot(Enc_Methods, KNN_Prec)
plt.plot(Enc_Methods, SVM_Prec)
plt.ylabel("Precision")
plt.xlabel("Method Number")
plt.legend(["DTC","KNN","SVM"])
plt.title("Precision Comparison of Resampling methods")

Enc_Methods = ["0","1","2","3"]
plt.plot(Enc_Methods, DTC_Rec)
plt.plot(Enc_Methods, KNN_Rec)
plt.plot(Enc_Methods, SVM_Rec)
plt.ylabel("Recall")
plt.xlabel("Method Number")
plt.legend(["DTC","KNN","SVM"])
plt.title("Recall Comparison of Resampling methods")
